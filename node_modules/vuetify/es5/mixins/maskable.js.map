{"version":3,"file":"maskable.js","sourceRoot":"","sources":["../../src/mixins/maskable.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Maskable\n *\n * @mixin\n *\n * Creates an input mask that is\n * generated from a masked str\n *\n * Example: mask=\"#### #### #### ####\"\n */\n\nimport {\n  isMaskDelimiter,\n  maskText,\n  unmaskText\n} from '../util/mask'\n\nexport default {\n  name: 'maskable',\n\n  data: () => ({\n    selection: 0,\n    lazySelection: 0,\n    preDefined: {\n      'credit-card': '#### - #### - #### - ####',\n      'date': '##/##/####',\n      'date-with-time': '##/##/#### ##:##',\n      'phone': '(###) ### - ####',\n      'social': '###-##-####',\n      'time': '##:##',\n      'time-with-seconds': '##:##:##'\n    }\n  }),\n\n  props: {\n    dontFillMaskBlanks: Boolean,\n    mask: {\n      type: [Object, String],\n      default: null\n    },\n    returnMaskedValue: Boolean\n  },\n\n  computed: {\n    masked () {\n      const preDefined = this.preDefined[this.mask]\n      const mask = preDefined || this.mask || ''\n\n      return mask.split('')\n    }\n  },\n\n  watch: {\n    /**\n     * Make sure the cursor is in the correct\n     * location when the mask changes\n     */\n    mask () {\n      if (!this.$refs.input) return\n\n      const oldValue = this.$refs.input.value\n      const newValue = this.maskText(unmaskText(this.lazyValue))\n      let position = 0\n      let selection = this.selection\n\n      for (let index = 0; index < selection; index++) {\n        isMaskDelimiter(oldValue[index]) || position++\n      }\n\n      selection = 0\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          isMaskDelimiter(newValue[index]) || position--\n          selection++\n          if (position <= 0) break\n        }\n      }\n\n      this.$nextTick(() => {\n        this.$refs.input.value = newValue\n        this.setCaretPosition(selection)\n      })\n    }\n  },\n\n  beforeMount () {\n    if (!this.mask ||\n      this.value == null ||\n      !this.returnMaskedValue\n    ) return\n\n    const value = this.maskText(this.value)\n\n    // See if masked value does not\n    // match the user given value\n    if (value === this.value) return\n\n    this.$emit('input', value)\n  },\n\n  methods: {\n    setCaretPosition (selection) {\n      this.selection = selection\n      window.setTimeout(() => {\n        this.$refs.input && this.$refs.input.setSelectionRange(this.selection, this.selection)\n      }, 0)\n    },\n    updateRange () {\n      if (!this.$refs.input) return\n\n      const newValue = this.maskText(this.lazyValue)\n      let selection = 0\n\n      this.$refs.input.value = newValue\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          if (this.lazySelection <= 0) break\n          isMaskDelimiter(newValue[index]) || this.lazySelection--\n          selection++\n        }\n      }\n\n      this.setCaretPosition(selection)\n      // this.$emit() must occur only when all internal values are correct\n      this.$emit('input', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue)\n    },\n    maskText (text) {\n      return this.mask ? maskText(text, this.masked, this.dontFillMaskBlanks) : text\n    },\n    unmaskText (text) {\n      return this.mask && !this.returnMaskedValue ? unmaskText(text) : text\n    },\n    // When the input changes and is\n    // re-created, ensure that the\n    // caret location is correct\n    setSelectionRange () {\n      this.$nextTick(this.updateRange)\n    },\n    resetSelections (input) {\n      if (!input.selectionEnd) return\n      this.selection = input.selectionEnd\n      this.lazySelection = 0\n\n      for (let index = 0; index < this.selection; index++) {\n        isMaskDelimiter(input.value[index]) || this.lazySelection++\n      }\n    }\n  }\n}\n"]}