'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

require('../../../src/stylus/components/_autocompletes.styl');

var _VSelect = require('../VSelect/VSelect');

var _VSelect2 = _interopRequireDefault(_VSelect);

var _VTextField = require('../VTextField/VTextField');

var _VTextField2 = _interopRequireDefault(_VTextField);

var _helpers = require('../../util/helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Styles
exports.default = {
    name: 'v-autocomplete',
    extends: _VSelect2.default,
    data: function data(vm) {
        return {
            attrsInput: null,
            lazySearch: vm.searchInput,
            lazyValue: vm.value != null ? vm.value : vm.multi || vm.tags ? [] : undefined
        };
    },
    props: {
        allowOverflow: {
            type: Boolean,
            default: true
        },
        asyncItems: Boolean,
        browserAutocomplete: {
            type: String,
            default: 'off'
        },
        combobox: Boolean,
        delimiters: Array,
        filter: {
            type: Function,
            default: function _default(item, queryText, itemText) {
                var hasValue = function hasValue(val) {
                    return val != null ? val : '';
                };
                var text = hasValue(itemText);
                var query = hasValue(queryText);
                return text.toString().toLowerCase().indexOf(query.toString().toLowerCase()) > -1;
            }
        },
        noFilter: Boolean,
        offsetY: {
            type: Boolean,
            default: true
        },
        offsetOverflow: {
            type: Boolean,
            default: true
        },
        searchInput: {
            default: undefined
        },
        tags: Boolean,
        transition: {
            type: [Boolean, String],
            default: false
        }
    },
    computed: {
        classes: function classes() {
            return Object.assign({}, _VSelect2.default.computed.classes.call(this), {
                'v-autocomplete': true,
                'v-autocomplete--is-selecting-index': this.selectedIndex > -1
            });
        },
        computedItems: function computedItems() {
            return this.filteredItems;
        },

        /**
         * The range of the current input text
         *
         * @return {Number}
         */
        currentRange: function currentRange() {
            if (this.selectedItem == null) return 0;
            return this.getText(this.selectedItem).toString().length;
        },
        filteredItems: function filteredItems() {
            var _this = this;

            if (!this.isSearching || this.noFilter) return this.allItems;
            return this.allItems.filter(function (i) {
                return _this.filter(i, _this.internalSearch, _this.getText(i));
            });
        },
        hasSlot: function hasSlot() {
            return _VSelect2.default.computed.hasSlot.call(this) || this.tags;
        },

        internalSearch: {
            get: function get() {
                return this.lazySearch;
            },
            set: function set(val) {
                this.lazySearch = val;
                this.$emit('update:searchInput', val);
            }
        },
        isAnyValueAllowed: function isAnyValueAllowed() {
            return this.combobox || this.tags;
        },
        isDirty: function isDirty() {
            return this.searchIsDirty || this.selectedItems.length > 0;
        },
        isMulti: function isMulti() {
            return this.tags || _VSelect2.default.computed.isMulti.call(this);
        },
        isSearching: function isSearching() {
            if (this.isMulti) return this.searchIsDirty;
            return this.internalSearch !== this.getText(this.selectedItem);
        },
        menuCanShow: function menuCanShow() {
            if (!this.isFocused) return false;
            var filtered = this.filteredItems.length > 0;
            if (this.isAnyValueAllowed) {
                return filtered;
            }
            return filtered || !this.asyncItems;
        },
        menuProps: function menuProps() {
            return Object.assign(_VSelect2.default.computed.menuProps.call(this), {
                contentClass: 'v-autocomplete__content',
                value: this.menuCanShow && this.isMenuActive
            });
        },
        searchIsDirty: function searchIsDirty() {
            return this.internalSearch != null && this.internalSearch !== '';
        },
        selectedItem: function selectedItem() {
            var _this2 = this;

            if (this.isMulti) return null;
            return this.selectedItems.find(function (i) {
                return _this2.valueComparator(_this2.getValue(i), _this2.getValue(_this2.internalValue));
            });
        },
        listData: function listData() {
            var data = _VSelect2.default.computed.listData.call(this);
            Object.assign(data.props, {
                items: this.virtualizedItems,
                noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,
                searchInput: this.internalSearch
            });
            return data;
        }
    },
    watch: {
        filteredItems: function filteredItems(val) {
            var _this3 = this;

            if (this.isAnyValueAllowed) return;
            this.setMenuIndex(-1);
            this.$nextTick(function () {
                _this3.setMenuIndex(val.length === 1 ? 0 : -1);
            });
        },
        internalValue: function internalValue() {
            this.setSearch();
        },
        isFocused: function isFocused(val) {
            if (val) {
                this.$refs.input && this.$refs.input.select();
            }
        },
        isMenuActive: function isMenuActive(val) {
            if (val || !this.hasSlot) return;
            this.lazySearch = null;
        },
        searchInput: function searchInput(val) {
            this.lazySearch = val;
        },
        internalSearch: function internalSearch(val) {
            if (val && this.tags && this.delimiters) {
                var delimiter = this.delimiters.find(function (d) {
                    return val.endsWith(d);
                });
                if (delimiter == null) return;
                this.internalSearch = val.slice(0, val.length - delimiter.length);
                this.updateTags();
            }
            if (this.isMenuActive && this.$refs.menu) {
                this.$refs.menu.updateDimensions();
            }
        }
    },
    created: function created() {
        this.setSearch();
    },

    methods: {
        activateMenu: function activateMenu() {
            if (this.menuCanShow) {
                this.isMenuActive = true;
            }
        },
        changeSelectedIndex: function changeSelectedIndex(keyCode) {
            // Do not allow changing of selectedIndex
            // when search is dirty
            if (this.searchIsDirty) return;
            if (![_helpers.keyCodes.backspace, _helpers.keyCodes.left, _helpers.keyCodes.right, _helpers.keyCodes.delete].includes(keyCode)) return;
            var indexes = this.selectedItems.length - 1;
            if (keyCode === _helpers.keyCodes.left) {
                this.selectedIndex = this.selectedIndex === -1 ? indexes : this.selectedIndex - 1;
            } else if (keyCode === _helpers.keyCodes.right) {
                this.selectedIndex = this.selectedIndex >= indexes ? -1 : this.selectedIndex + 1;
            } else if (this.selectedIndex === -1) {
                this.selectedIndex = indexes;
                return;
            }
            var currentItem = this.selectedItems[this.selectedIndex];
            if ([_helpers.keyCodes.backspace, _helpers.keyCodes.delete].includes(keyCode) && !this.getDisabled(currentItem)) {
                var newIndex = this.selectedIndex === indexes ? this.selectedIndex - 1 : this.selectedItems[this.selectedIndex + 1] ? this.selectedIndex : -1;
                if (newIndex === -1) {
                    this.internalValue = this.isMulti ? [] : undefined;
                } else {
                    this.selectItem(currentItem);
                }
                this.selectedIndex = newIndex;
            }
        },
        genInput: function genInput() {
            var input = _VTextField2.default.methods.genInput.call(this);
            input.data.attrs.role = 'combobox';
            input.data.domProps.value = this.internalSearch;
            return input;
        },
        genSelections: function genSelections() {
            return this.hasSlot || this.isMulti ? _VSelect2.default.methods.genSelections.call(this) : [];
        },
        onBlur: function onBlur(e) {
            this.updateSelf();
            _VSelect2.default.methods.onBlur.call(this, e);
        },
        onClick: function onClick() {
            if (this.isDisabled) return;
            this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus();
            this.activateMenu();
        },
        onInput: function onInput(e) {
            if (this.selectedIndex > -1) return;
            // If typing and menu is not currently active
            if (e.target.value) {
                this.activateMenu();
                if (!this.isAnyValueAllowed) this.setMenuIndex(0);
            }
            this.mask && this.resetSelections(e.target);
            this.internalSearch = e.target.value;
            this.badInput = e.target.validity && e.target.validity.badInput;
        },
        onKeyDown: function onKeyDown(e) {
            var keyCode = e.keyCode;
            _VSelect2.default.methods.onKeyDown.call(this, e);
            // If user is at selection index of 0
            // create a new tag
            if (this.tags && keyCode === _helpers.keyCodes.left && this.$refs.input.selectionStart === 0) {
                this.updateSelf();
            }
            // The ordering is important here
            // allows new value to be updated
            // and then moves the index to the
            // proper location
            this.changeSelectedIndex(keyCode);
        },
        onTabDown: function onTabDown(e) {
            var menuIndex = this.getMenuIndex();
            // When adding tags, if searching and
            // there is not a filtered options,
            // add the value to the tags list
            if (this.tags && this.internalSearch && menuIndex === -1) {
                e.preventDefault();
                e.stopPropagation();
                return this.updateTags();
            } else {
                _VSelect2.default.methods.onTabDown.call(this, e);
            }
            this.updateSelf();
        },
        selectItem: function selectItem(item) {
            _VSelect2.default.methods.selectItem.call(this, item);
            this.setSearch();
        },
        setSelectedItems: function setSelectedItems() {
            if (this.internalValue == null || this.internalValue === '') {
                this.selectedItems = [];
            } else if (this.tags) {
                this.selectedItems = this.internalValue;
            } else if (this.combobox) {
                this.selectedItems = [this.internalValue];
            } else {
                _VSelect2.default.methods.setSelectedItems.call(this);
            }
        },
        setSearch: function setSearch() {
            var _this4 = this;

            // Wait for nextTick so selectedItem
            // has had time to update
            this.$nextTick(function () {
                _this4.internalSearch = !_this4.selectedItem || _this4.isMulti || _this4.hasSlot ? null : _this4.getText(_this4.selectedItem);
            });
        },
        setValue: function setValue() {
            this.internalValue = this.internalSearch;
            this.$emit('change', this.internalSearch);
        },
        updateAutocomplete: function updateAutocomplete() {
            if (!this.searchIsDirty && !this.internalValue) return;
            if (!this.valueComparator(this.internalSearch, this.getValue(this.internalValue))) {
                this.setSearch();
            }
        },
        updateCombobox: function updateCombobox() {
            // When using chips and search is dirty
            // avoid updating input
            if (this.chips && !this.searchIsDirty) return;
            // The internal search is not matching
            // the initial value, update the input
            if (this.internalSearch !== this.internalValue) this.setValue();
            // Reset search if using chips
            // to avoid a double input
            if (this.chips) this.internalSearch = undefined;
        },
        updateSelf: function updateSelf() {
            if (this.tags) this.updateTags();else if (this.combobox) this.updateCombobox();else this.updateAutocomplete();
        },

        // Maybe change to onBlur?
        updateTags: function updateTags() {
            var menuIndex = this.getMenuIndex();
            // If the user is not searching
            // and no menu item is selected
            // do nothing
            if (menuIndex < 0 && !this.searchIsDirty) return;
            var index = this.selectedItems.indexOf(this.internalSearch);
            // If it already exists, do nothing
            // this might need to change to bring
            // the duplicated item to the last entered
            if (index > -1) {
                this.internalValue.splice(index, 1);
            }
            // If menu index is greater than 1
            // the selection is handled elsewhere
            // TODO: find out where
            if (menuIndex > -1) return this.internalSearch = null;
            this.selectItem(this.internalSearch);
            this.internalSearch = null;
        }
    }
};
// Utils

// Extensions
//# sourceMappingURL=VAutocomplete.js.map