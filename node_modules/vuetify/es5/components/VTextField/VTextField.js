'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // Styles

// Extensions

// Components

// Mixins

// Directives

// Utilities


require('../../../src/stylus/components/_text-fields.styl');

var _VInput = require('../VInput');

var _VInput2 = _interopRequireDefault(_VInput);

var _VCounter = require('../VCounter');

var _VCounter2 = _interopRequireDefault(_VCounter);

var _VLabel = require('../VLabel');

var _VLabel2 = _interopRequireDefault(_VLabel);

var _maskable = require('../../mixins/maskable');

var _maskable2 = _interopRequireDefault(_maskable);

var _ripple = require('../../directives/ripple');

var _ripple2 = _interopRequireDefault(_ripple);

var _helpers = require('../../util/helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dirtyTypes = ['color', 'file', 'time', 'date', 'datetime-local', 'week', 'month'];
exports.default = {
    name: 'v-text-field',
    extends: _VInput2.default,
    mixins: [_maskable2.default],
    directives: { Ripple: _ripple2.default },
    inheritAttrs: false,
    data: function data() {
        return {
            badInput: false,
            initialValue: null,
            internalChange: false,
            isClearing: false
        };
    },
    props: {
        appendOuterIcon: String,
        autofocus: Boolean,
        box: Boolean,
        browserAutocomplete: String,
        clearable: Boolean,
        clearIcon: {
            type: String,
            default: '$vuetify.icons.clear'
        },
        clearIconCb: Function,
        color: {
            type: String,
            default: 'primary'
        },
        counter: [Boolean, Number, String],
        flat: Boolean,
        fullWidth: Boolean,
        label: String,
        outline: Boolean,
        placeholder: String,
        prefix: String,
        reverse: Boolean,
        singleLine: Boolean,
        solo: Boolean,
        soloInverted: Boolean,
        suffix: String,
        textarea: Boolean,
        type: {
            type: String,
            default: 'text'
        }
    },
    computed: {
        classes: function classes() {
            return {
                'v-text-field': true,
                'v-text-field--full-width': this.fullWidth,
                'v-text-field--prefix': this.prefix,
                'v-text-field--single-line': this.isSingle,
                'v-text-field--solo': this.isSolo,
                'v-text-field--solo-inverted': this.soloInverted,
                'v-text-field--box': this.box,
                'v-text-field--enclosed': this.isEnclosed,
                'v-text-field--reverse': this.reverse,
                'v-text-field--outline': this.hasOutline,
                'elevation-0': this.flat
            };
        },
        directivesInput: function directivesInput() {
            return [];
        },

        // TODO: Deprecate
        hasOutline: function hasOutline() {
            return this.outline || this.textarea;
        },

        internalValue: {
            get: function get() {
                return this.lazyValue;
            },
            set: function set(val) {
                if (this.mask) {
                    this.lazyValue = this.unmaskText(this.maskText(this.unmaskText(val)));
                    this.setSelectionRange();
                } else {
                    this.lazyValue = val;
                    this.$emit('input', this.lazyValue);
                }
            }
        },
        isDirty: function isDirty() {
            return this.lazyValue != null && this.lazyValue.toString().length > 0 || this.badInput;
        },
        isEnclosed: function isEnclosed() {
            return this.isSolo || this.hasOutline || this.fullWidth;
        },
        isLabelActive: function isLabelActive() {
            return this.isDirty || dirtyTypes.includes(this.type);
        },
        isSingle: function isSingle() {
            return this.isSolo || this.singleLine;
        },
        isSolo: function isSolo() {
            return this.solo || this.soloInverted;
        }
    },
    watch: {
        isFocused: function isFocused(val) {
            // Sets validationState from validatable
            this.hasColor = val;
            if (val) {
                this.initialValue = this.lazyValue;
            } else if (this.initialValue !== this.lazyValue) {
                this.$emit('change', this.lazyValue);
            }
        },
        value: function value(val) {
            var _this = this;

            if (this.mask && !this.internalChange) {
                var masked = this.maskText(this.unmaskText(val));
                this.lazyValue = this.unmaskText(masked);
                // Emit when the externally set value was modified internally
                String(val) !== this.lazyValue && this.$nextTick(function () {
                    _this.$refs.input.value = masked;
                    _this.$emit('input', _this.lazyValue);
                });
            } else this.lazyValue = val;
            if (this.internalChange) this.internalChange = false;
        }
    },
    mounted: function mounted() {
        this.autofocus && this.onFocus();
    },

    methods: {
        /** @public */
        focus: function focus() {
            this.onFocus();
        },

        /** @public */
        blur: function blur() {
            this.onBlur();
        },
        clearableCallback: function clearableCallback() {
            var _this2 = this;

            this.internalValue = null;
            this.$nextTick(function () {
                return _this2.$refs.input.focus();
            });
        },
        genAppendSlot: function genAppendSlot() {
            var slot = [];
            if (this.$slots['append-outer']) {
                slot.push(this.$slots['append-outer']);
            } else if (this.$slots['append-outer-icon']) {
                slot.push(this.$slots['append-outer-icon']);
            } else if (this.appendOuterIcon) {
                slot.push(this.genIcon('appendOuter'));
            }
            return this.genSlot('append', 'outer', slot);
        },
        genClearIcon: function genClearIcon() {
            if (!this.clearable) return null;
            var icon = !this.isDirty ? false : 'clear';
            return this.genSlot('append', 'inner', [this.genIcon(icon, this.clearIconCb || this.clearableCallback)]);
        },
        genCounter: function genCounter() {
            if (this.counter === false) return null;
            var value = (this.internalValue || '').length;
            var max = this.counter === true ? this.$attrs.maxlength : this.counter;
            return this.$createElement(_VCounter2.default, {
                props: {
                    value: value,
                    max: max
                }
            });
        },
        genDefaultSlot: function genDefaultSlot() {
            return [this.genTextFieldSlot(), this.genClearIcon(), this.genIconSlot()];
        },
        genLabel: function genLabel() {
            if (this.isSingle && (this.isDirty || !!this.placeholder)) return null;
            var isSingleLine = this.isSingle;
            var value = 0;
            var left = 'auto';
            var right = 'auto';
            // Create spacing
            if ((this.prefix || this.reverse) && (isSingleLine || !this.isFocused) && !this.isDirty) value = 16;
            // Check if RTL
            if (this.$vuetify.rtl) right = value;else left = value;
            // Check if reversed
            if (this.reverse) {
                var direction = right;
                right = left;
                left = direction;
            }
            var data = {
                props: {
                    absolute: true,
                    color: this.validationState,
                    disabled: this.disabled,
                    focused: !isSingleLine && (this.isFocused || !!this.validationState),
                    left: left,
                    right: right,
                    value: Boolean(!isSingleLine && (this.isFocused || this.isDirty || this.placeholder))
                }
            };
            if (this.$attrs.id) data.props.for = this.$attrs.id;
            return this.$createElement(_VLabel2.default, data, this.$slots.label || this.label);
        },
        genIconSlot: function genIconSlot() {
            var slot = [];
            if (this.$slots['append']) {
                slot.push(this.$slots['append']);
            } else if (this.$slots['append-icon']) {
                slot.push(this.$slots['append-icon']);
            } else if (this.appendIcon) {
                slot.push(this.genIcon('append'));
            }
            return this.genSlot('append', 'inner', slot);
        },
        genInput: function genInput() {
            var listeners = Object.assign({}, this.$listeners);
            delete listeners['change']; // Change should not be bound externally
            var data = {
                style: {},
                domProps: {
                    value: this.maskText(this.lazyValue)
                },
                attrs: _extends({}, this.$attrs, {
                    autofocus: this.autofocus,
                    disabled: this.disabled,
                    required: this.required,
                    readonly: this.readonly,
                    tabindex: this.tabindex,
                    type: this.type,
                    'aria-label': (!this.$attrs || !this.$attrs.id) && this.label // Label `for` will be set if we have an id
                }),
                on: Object.assign(listeners, {
                    blur: this.onBlur,
                    input: this.onInput,
                    focus: this.onFocus,
                    keydown: this.onKeyDown
                }),
                ref: 'input'
            };
            if (this.placeholder) data.attrs.placeholder = this.placeholder;
            if (this.mask) data.attrs.maxlength = this.masked.length;
            if (this.browserAutocomplete) data.attrs.autocomplete = this.browserAutocomplete;
            return this.$createElement('input', data);
        },
        genMessages: function genMessages() {
            return this.$createElement('div', {
                staticClass: 'v-text-field__details'
            }, [_VInput2.default.methods.genMessages.call(this), this.genCounter()]);
        },
        genTextFieldSlot: function genTextFieldSlot() {
            return this.$createElement('div', {
                staticClass: 'v-text-field__slot'
            }, [this.genLabel(), this.prefix ? this.genAffix('prefix') : null, this.genInput(), this.suffix ? this.genAffix('suffix') : null]);
        },
        genAffix: function genAffix(type) {
            return this.$createElement('div', {
                'class': 'v-text-field__' + type,
                ref: type
            }, this[type]);
        },
        onBlur: function onBlur(e) {
            this.isFocused = false;
            // Reset internalChange state
            // to allow external change
            // to persist
            this.internalChange = false;
            this.$emit('blur', e);
        },
        onClick: function onClick() {
            if (this.isFocused || this.disabled) return;
            this.$refs.input.focus();
        },
        onFocus: function onFocus(e) {
            if (!this.$refs.input) return;
            if (document.activeElement !== this.$refs.input) {
                return this.$refs.input.focus();
            }
            if (!this.isFocused) {
                this.isFocused = true;
                this.$emit('focus', e);
            }
        },
        onInput: function onInput(e) {
            this.mask && this.resetSelections(e.target);
            this.internalValue = e.target.value;
            this.badInput = e.target.validity && e.target.validity.badInput;
        },
        onKeyDown: function onKeyDown(e) {
            this.internalChange = true;
            if (e.keyCode === _helpers.keyCodes.enter) this.$emit('change', this.internalValue);
            this.$emit('keydown', e);
        },
        onMouseDown: function onMouseDown(e) {
            // Prevent input from being blurred
            if (e.target !== this.$refs.input) {
                e.preventDefault();
                e.stopPropagation();
            }
            _VInput2.default.methods.onMouseDown.call(this, e);
        },
        onMouseUp: function onMouseUp(e) {
            // Default click handler is on slot,
            // Mouse events are to enable specific
            // input types when clicked
            if ((this.isSolo || this.hasOutline) && document.activeElement !== this.$refs.input) {
                this.$refs.input.focus();
            }
            _VInput2.default.methods.onMouseUp.call(this, e);
        }
    }
};
//# sourceMappingURL=VTextField.js.map